#!/bin/bash
# =============================================================================
# @file    archive-micropublication
# @brief   Script meant to be run from cron
# @author  Michael Hucka <mhucka@caltech.edu>
# @license Please see the file named LICENSE in the project directory
# @website https://github.com/caltechlibrary/microarchiver
#
# Principles:
#
#  1. The frequency of archives is set by the cron schedule, not in here.
#
#  2. The local output directory where files are saved is set by environment
#     variable PORTICO_OUTPUT.
#
#  3. A timestamp file is created in the output directory, and microarchiver
#     is run with that date stamp as the "after date" argument.
#
#  4. Archives are created in subdirectories of the output directory named
#     after the date+time they were done.  E.g., "2019-08-29-1000".
#
#  5. A report file is written to the output directory and named "report.csv".
#
#  6. A log file is written to the output directory and named "run.log".
#
#  7. Successful results are uploaded to ftp.portico.org using ftp credentials
#     that are passed via environment variables PORTICO_USER and PORTICO_PASS.
#
#  8. Outcomes are emailed to the comma-separated addresses in environment
#     variable $EMAIL_SUCCESS or $EMAIL_FAILURE, depending on whether
#     execution succeed or failed, respectively.  They are also posted to the
#     Slack channel set by environment vaiable SLACK_CHANNEL using API token
#     SLACK_CLI_TOKEN.  (Note: SLACK_CLI_TOKEN is read by the command
#     `slack`, which is why it does not appear used below.)
#
# =============================================================================

# Files recording the results of the most recent run are stored at the level
# of the directory indicatd by $PORTICO_OUTPUT, because this information is
# carried across runs.

today=$(date +%Y-%m-%d)
datestampfile=$PORTICO_OUTPUT/last-run-date
failurefile=$PORTICO_OUTPUT/last-failures

# Today's run will be written in a subdirctory.  Note the subdirectory name
# includes the current time, not just today's date, because otherwise we
# would overwrite the previous data if we ran run multiple times per day.

now=$(date +%Y-%m-%d-%H%M)
outputdir=$PORTICO_OUTPUT/$now

log=$outputdir/run.log
report=$outputdir/report.csv
debuglog=$outputdir/debug.log

# Infer the directory where this script is located.  Used for error messages.
CWD="$(cd -P -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd -P)"
thiscript=$CWD/$(basename ${BASH_SOURCE[0]})


# Define helper functions -----------------------------------------------------

run_microarchiver() {
    # First make sure we can find microarchiver. If not, send mail & quit.
    if ! command -v microarchiver &> /dev/null; then
        body=$(cat <<EOF
This is an error message generated by the process running microarchiver for
uploading publications to Portico. The process is unable to find the
program "microarchiver". This indicates either a configuration problem or
a change in the computer system where the process is executed. Manual
intervention is required. Additional information may be found here:

  computer: `hostname`
  directory: $outputdir

This message was produced by $thiscript on `hostname`.
EOF
)
        echo "$body" | mail -s"microarchiver failure $today" $EMAIL_FAILURE
        run_slack chat send --channel $SLACK_CHANNEL --color "#ff0000" \
              --title "Error: unable to upload micropublication.org to Portico" \
              --text "$thiscript on `hostname` cannot find program 'microarchiver'"
        exit 1
    fi

    # Run microarchiver with arguments and save output in $log
    microarchiver $@ >> $log 2>&1

    # Was it a successful run? If not, send mail & quit.
    status=$?
    if (($status > 0 && $status < 100)); then
        case "$status" in
            1) cause="No network detected" ;;
            2) cause="The user interrupted program execution" ;;
            3) cause="An exception or fatal error occurred during execution" ;;
            *) cause="An unexpected error occurred during execution" ;;
        esac
        body=$(cat <<EOF
This is an error message generated by the process running microarchiver for
uploading publications to Portico. While doing its work, microarchiver has
encountered the following error:

   $cause

The attached log file may indicate a reason for the failure. Look at the
bottom the log file to see what was the last action attempted.

Today's upload to Portico has been stopped.
EOF
)
        echo "$body" | mail -s"microarchiver failure $today" -a $log $EMAIL_FAILURE
        run_slack chat send --channel $SLACK_CHANNEL --color "#ff0000" \
              --title "Error: unable to complete Portico archiving for micropublication.org" \
              --text "microarchiver failed to create archive file for Portico. Cause: $cause."
        run_slack file upload --channels $SLACK_CHANNEL --file $log \
              --comment "Here is the microarchiver run log"
        exit $status
    fi
}

run_slack() {
    # First make sure we can find slack. If not, log it and return silently.
    if ! command -v slack &> /dev/null; then
        echo "Unable to find slack" >> $log
        return
    fi

    # Run slack-cli with arguments. Send its output to /dev/null because it
    # always returns a JSON blob (no way to turn it off) and the resulting
    # output will cause cron to think it should be mailed to the user.
    slack "$@" > /dev/null 2>&1
}


# Do the real work ------------------------------------------------------------

# Before doing anything else, create the output directory.
mkdir -p $outputdir

# Start by recording the current time.
echo "Starting at $now" >> $log
echo "" >> $log

# Read the date stamp from the previous run.
if [[ -e $datestampfile ]]; then
    read lastrun < $datestampfile
else
    # We've never run, or someone reset the date stamp.
    # Use a fake date that basically signifies "since forever".
    lastrun="1900-01-01"
fi

# Run microarchiver separately on past failures, leaving the results unpackaged
# so that we can add to them the results of today's run.
if [[ -f $failurefile ]]; then
    echo "=== Running microarchiver on past failures ===" >> $log
    # Note the use of -Z to prevent zip'ing the final results.
    run_microarchiver -Z -C -a $failurefile -o $outputdir -r $report -@ $debuglog
    echo "" >> $log
fi

echo "=== Running microarchiver for new articles ===" >> $log
thisreport=$outputdir/latest-report.csv
thisdebuglog=$outputdir/latest-debug.log
# This will add new articles to any existing ones from the past failures
# code above, and this time will zip up the final result.
run_microarchiver -C -d $lastrun -o $outputdir -r $thisreport -@ $thisdebuglog

# Combine separate report files, leave that, & delete the intermediate files.
tail -n +2 $thisreport >> $report
tail $thisdebuglog >> $debuglog
rm -f $thisdebuglog $thisreport

# Did we have any failures? If so, note them for next time.
grep -i "missing," $outputdir/*report.csv | cut -f2 -d',' > $failurefile

# If we downloaded new articles, ftp the archive to Portico.
# Note #1: the file redirection is to avoid wc printing the file name.
# Note #2: the -gt 1 is to skip the header line when counting the lines.
lines=$(wc -l < $report)
if [[ $lines -gt 1 ]]; then
    archivefile=$outputdir/micropublication-org.zip
    echo "" >> $log
    echo "=== FTP'ing file using curl ===" >> $log
    curl -T $archivefile ftp://ftp.portico.org \
        --user $PORTICO_USER:$PORTICO_PASS >> $log 2>&1
fi

# If we get this far, write out a date stamp file to indicate that things
# ran successfully and to give the next run a starting point.
echo $today > $datestampfile

# Mail the report -------------------------------------------------------------

grep -F "Total articles" $log | \
    sed 's/Total //g;1 s/articles/Past failures retried/;2 s/articles/New &/' | \
    mail -s"Portico archiving results for $today" -a $report -a $log $EMAIL_SUCCESS

# Post the report to Slack ----------------------------------------------------

run_slack chat send --channel $SLACK_CHANNEL --color "#00ff00" \
    --title "microarchiver successfully completed Portico upload" \
    --text "There were $(wc -l < $failurefile) articles skipped."
run_slack file upload --channels $SLACK_CHANNEL --file $report \
    --comment "Here is the record of what was uploaded:"
